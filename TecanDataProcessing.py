# -*- coding: utf-8 -*-
"""
Created on Wed Jun 14 10:39:09 2023

@author: Marina Dziuba
"""
import sys
import pandas as pd

##Parsing the input text file with replicates
def replicates_to_dictionary(file):
    '''Parse lines with the information on sample names and position of 
    replicates on a multiwell plate and returns it as dictionary for further processing'''
    with open(file, 'r') as f:
        replicates = dict()
        lines = f.readlines()
        lines = [line.strip() for line in lines]
        for line in lines:
            rep = line.split(':')
            wells = rep[1].split(',')
            wells = [well.strip() for well in wells]
            replicates[rep[0]] = tuple(wells)
    return(replicates)

##Data extraction and processing functions for typical Tecan output spreadsheets

def test_table_orientation(tecan_tbl, measurements_location):
    '''Check if data in the exel table are in the horizontal orientation. 
    Otherwise the data extraction will not work. Accepts the table generated by 
    Tecan read with pandas and the tuple with row numbers indicating the start and the end of the
    measurements in this table'''
    try:
        test_horizontal = list(tecan_tbl.iloc[measurements_location[0]-1, 1:11])
        test_horizontal = [int(i) for i in test_horizontal]
        test_horizontal == [1,2,3,4,5,6,7,8,9,10]
    except:
        print("Error: the data in your Excel sheet is not arranged horizontally")
        sys.exit()
        
        

def select_data(tecan_tbl, measurements_location):
    '''Extract the rows containing data according to the user specified location
    of measurements. Accepts the table generated by Tecan read with pandas and a 
    tuple with row numbers indicating the start and the end of the measurements 
    in this table'''
    
    data = tecan_tbl.iloc[(measurements_location[0]-2):(measurements_location[1]-1), :].reset_index(drop = True)

    return data


def process_time(data):
    '''Extract time (s) from the data, calculate time in hours, and add both to a new dataframe 
    as transformed columns'''
    #create a new dataframe
    time_df = pd.DataFrame(dtype="object")
    for i, r in data.iterrows():
        if r[0] == "Zeit [s]" or r[0] == "Time [s]":
            time_df[0] = r.T
            break
    time_df.reset_index(drop = True, inplace = True)
    
    #Transform time to hours and write the result to a new column
    time_hr = time_df.iloc[1:,0].divide(3600)
    time_hr.loc[-1] = "Time [h]"
    time_hr = time_hr.sort_index()
    time_hr.reset_index(drop = True, inplace = True)
    time_df = pd.concat([time_df, time_hr], axis=1, ignore_index=True)
    
    return time_df


def extract_values_with_multimeasurements(well, data):
    '''Extract the mean value of multiple measurements in a specified well. 
    Suitable if measurements were conducted in several points (a setting 
    available in Tecan i-control software). Well should be passed as a string 
    (e.g., 'A1', 'A2', etc.)'''

    #In our lab, the data could be written in English or in German. 
    #The language should be tested for correct data extraction
    try:
        well_index = data[data["Application: Tecan i-control"] == well].index
    except:
        well_index = data[data["Programm: Tecan i-control"] == well].index
    
    well_values = data.iloc[well_index + 3, :] #Find the correct row
    well_values_T = well_values.T #Transpose the data from the selected row
    well_values_T.reset_index(drop = True, inplace = True) #Reset the index
    return  well_values_T


def extract_values_with_monomeasurements(well, data):
    '''Extract the values measured in a well if a single measurement was conducted. 
    Well should be passed as a string (e.g., 'A1', 'A2', etc.)'''
    try:
        well_index = data[data["Application: Tecan i-control"] == well].index
    except:
        well_index = data[data["Programm: Tecan i-control"] == well].index
    
    well_values = data.iloc[well_index, :]
    well_values_T = well_values.T #transposes the data from the selected row
    well_values_T.reset_index(drop = True, inplace = True)
    return  well_values_T

### Here a function to process data wih monomeasurements should be added!!
def process_extracted_multimeasurements(data, time_df, replicates, blank_values):
    '''Collect measurements for all replicates specified by user, if multiple
    reads per well were obtained, subtract the blank values, calculate mean 
    value and standard deviation for each time point, and add the results to the 
    previously generated dataframe containing time measurements. Return a tidy 
    dataframe with all the extracted data, calculated means and standard deviations.'''
    tidy_df = pd.DataFrame(dtype = 'object')
    tidy_df = pd.concat([tidy_df, time_df], axis=1, ignore_index=True)
    for k, v in replicates.items():
       for i in v:
           values = extract_values_with_multimeasurements(i, data)
           #subtract blank values from measurements
           values.iloc[1:,0] = values.iloc[1:,0].subtract(blank_values.iloc[1:, 0]) 
           values.iloc[0,0] =str(k + " : " + i)
           tidy_df = pd.concat([tidy_df, values], axis=1, ignore_index=True)        
       #Calculate mean value for the replicates 
       row_means = tidy_df.iloc[1:, -len(v):].mean(axis = 1)
       #Calculate standard deviation for the replicates
       row_std = tidy_df.iloc[1:, -len(v):].std(axis = 1)
       #Add mean value the df and assign a name to the column
       tidy_df = pd.concat([tidy_df, row_means], axis=1, ignore_index=True)
       tidy_df.iloc[0,-1] = str(k + " : " + "Mean value")
       #Add st. dev. to the df and assign a name to the column
       tidy_df = pd.concat([tidy_df, row_std], axis = 1, ignore_index=True)
       tidy_df.iloc[0,-1] = str(k + " : " + "St. dev")
      
    #Pass the first row as colum names
    tidy_df.columns = tidy_df.iloc[0]
    tidy_df = tidy_df.drop(0)
    tidy_df.reset_index(drop = True, inplace = True)

    #Correct any values lower than 0 to 0.01. This is needed to avoid negative 
    #values and division by 0. Negative values originate from low sensitivity 
    #of the spectrophotometric measurements in diluted samples.  
    tidy_df[tidy_df < 0] = 0.01
    
    return tidy_df

def process_extracted_monomeasurements(data, time_df, replicates):
    ''' Collect measurements for all replicates specified by user, if single 
    read per well was obtained, calculate mean value 
    and standard deviation for each time point, and add the results to the 
    previously generated dataframe containing time measurements. Return a tidy 
    dataframe with all the extracted data, calculated means and standard deviations.'''
    tidy_df = pd.DataFrame(dtype = 'object')
    tidy_df = pd.concat([tidy_df, time_df], axis=1, ignore_index=True)
    
    for k, v in replicates.items():
        for i in v:
            values = extract_values_with_monomeasurements(i, data)
            values.iloc[0,0] =str(k + " : " + i)
            tidy_df = pd.concat([tidy_df, values], axis=1, ignore_index=True)        
        #Calculate mean value for the replicates 
        row_means = tidy_df.iloc[1:, -len(v):].mean(axis = 1)
        #Calculate standard deviation for the replicates
        row_std = tidy_df.iloc[1:, -len(v):].std(axis = 1)
        #Add mean value and std to the df
        tidy_df = pd.concat([tidy_df, row_means], axis=1, ignore_index=True)
        tidy_df.iloc[0,-1] = str(k + " : " + "Mean value")
        tidy_df = pd.concat([tidy_df, row_std], axis = 1, ignore_index=True)
        tidy_df.iloc[0,-1] = str(k + " : " + "St. dev")
        
    #Pass the first row as colum names
    tidy_df.columns = tidy_df.iloc[0]
    tidy_df = tidy_df.drop(0)
    tidy_df.reset_index(drop = True, inplace = True)
    
    return tidy_df

def normalize_measurements():
    pass

def write_to_excel(outputname):
    '''Initiate an excel file for writing processed data'''
    excel = pd.ExcelWriter(outputname +".xlsx", engine = "xlsxwriter")
    return excel
