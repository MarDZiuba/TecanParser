# -*- coding: utf-8 -*-
"""
Created on Wed Jun 14 11:16:05 2023
v. 0.1
@author: Marina Dziuba
"""

#Imports-----------------------------------------------------------------------

import argparse
import pandas as pd
import sys
import TecanDataProcessing as tdprocess



# Arguments introduced by a user----------------------------------------------- 

parser = argparse.ArgumentParser(prog = 'TecanParser', 
                                 description = 'Processes the kinetic measurements produced by multiwell microplate readers of TecanÂ® (Infinite 200 Pro series) and converts them into tidy excel tables and simple plots. Current version can handle up to two different measurements.'
                                 )
parser.add_argument('--version', action = 'version', version = '%(prog)s 1.0')
parser.add_argument('-i', '--inputfile', type = str, help = 'File name or path to output .xls file generated by a Tecan device', required = True)
parser.add_argument('-o', '--outputname', help = 'Name you want to add to all your output files (e.g. GrowthExperiment -> GrowthExperiment.xlsx)', default = 'result')
parser.add_argument('-m1', '--measurement1', help = 'Name of your first type of measurements (e.g., OD600, growth, luminescence, etc.). It will be used as label for processed data and graphs', required = True, default = 'OD')
parser.add_argument('-m2', '--measurement2', help = 'Name of your second type of measurements (e.g., growth, luminescence), if applicable. It will be used as label for processed data and graphs', required = False)
parser.add_argument('-db1', '--data_boundaries1', help = 'Indicate the starting and the ending row number from the input excel file for the first type of measurements. Type numbers separated by space (e.g. 69 1219)', nargs = 2, type = int, required = True)
parser.add_argument('-db2', '--data_boundaries2', help = 'Indicate the starting and the ending row number from the input excel file for the second type of measurements. Type numbers separated by space (e.g. 69 1219)', nargs = 2, type = int, required = False)
parser.add_argument('-b', '--blank', help = 'Indicate a well with blank measurements (e.g., A1)', required = True)
parser.add_argument('-r', '--replicates', help = 'Text file containing information on sample names and the corresponding wells with replicate measurements. See README.md for details on how to create such text files')
parser.add_argument('-f', '--format',help = 'Saving format for the plots. Available options: pdf, eps, svg, png, jpeg, tiff', default = 'pdf', type = str, required = False)

args = parser.parse_args()

# Variables (from user arguments)----------------------------------------------

inputfile = args.inputfile
outputname = args.outputname
keyword1 = args.measurement1
mode1 = input('\n Did you obtain multiple reads per well for measurement_1? [yes/no] ')
mode1 = mode1.rstrip()
if mode1.lower() != 'yes' and mode1.lower() != 'no':
    sys.exit('Error: invalid answer is given. Only yes or no is accepted')

if args.measurement2:
    keyword2 = args.measurement2
    mode2 = input('\n Did you obtain multiple reads per well for measurement_2? [yes/no] ')
    mode2 = mode2.rstrip()
    if mode2.lower() != 'yes' and mode2.lower() != 'no':
        sys.exit('Error: invalid answer is given. Only yes or no is accepted')

data_boundaries1 = tuple(args.data_boundaries1)

if args.data_boundaries2:
    data_boundaries2 = args.data_boundaries2
    
blank = args.blank
replicates = tdprocess.replicates_to_dictionary(args.replicates)

#reade the tecan file as pandas df
tecan_data = pd.read_excel(inputfile) 
#select the data for measurement1 defined by data boundaries 
measurement1 = tdprocess.select_data(tecan_data, data_boundaries1)
measurement1_df = pd.DataFrame(dtype="object") #create an empty df to store tidy data for measurement1


# Main application-------------------------------------------------------------

##################### Processing and saving data ##############################

# test if data is in horizontal orientation. If not, exits the program
tdprocess.test_table_orientation(tecan_data, data_boundaries1)

# extract the time column, calculate hours from seconds and store both columns in a new df
time_df = tdprocess.process_time(measurement1)

# extract the reads for measurement1 and add them to the time df

if mode1.lower() == 'yes':
    blank_values = tdprocess.extract_values_with_multimeasurements(blank, measurement1)

elif mode1.lower() == 'no':
    blank_values = tdprocess.extract_values_with_monomeasurements(blank, measurement1)
    
blank_values.iloc[0,0] = "Blank"

# process the selected data by subtracting blank, calculating mean value and standard deviation.
# add the result to the new ('tidy') df

if mode1.lower() == 'yes':
    m1_tidy_df = tdprocess.process_extracted_multimeasurements(data = measurement1, 
                                                            time_df=time_df, replicates=replicates, 
                                                            blank_values=blank_values)
else:
    m1_tidy_df = tdprocess.process_extracted_monomeasurements(data = measurement1, 
                                                            time_df=time_df, replicates=replicates, 
                                                            )

# writing tidy data of the first measurement to excel

excel = tdprocess.write_to_excel(outputname)
m1_tidy_df.to_excel(excel, sheet_name = keyword1, index = False)

#process the data for the second measurement if applicable and save it to a new ('tidy') df 
if args.measurement2 and args.data_boundaries2:
    measurement2 = tdprocess.select_data(tecan_data, data_boundaries2)
    if mode2.lower() == 'yes':    
        m2_tidy_df = tdprocess.process_extracted_multimeasurements(data = measurement2, 
                                                                time_df=time_df, replicates=replicates, 
                                                                blank_values=blank_values)
    elif mode2.lower() == 'no':
        m2_tidy_df = tdprocess.process_extracted_monomeasurements(data = measurement2, 
                                                                time_df=time_df, replicates=replicates)    
    # writing tidy data of the secind measurement to excel
    m2_tidy_df.to_excel(excel, sheet_name = keyword2 + '_AU', index = False)

    # measurements normalyzation and saving to the same excel file as a separate sheet
    norm_df = tdprocess.normalize_measurements(m1_tidy_df, m2_tidy_df)
    norm_df.to_excel(excel, sheet_name = keyword2 + '_RLU', index = False)

excel.close()

######################### Plotting data #######################################

check_if_plot = input('\n Do you wish to plot the data? [yes/no] ')
check_if_plot = check_if_plot.rstrip()

if check_if_plot.lower() != 'yes':
    sys.exit('\n No plots to create. Exiting the application.')
else: 
    format = args.format
    print('\n Creating plots...')
    
import seaborn as sns
import TecanDataPlotting as tdplot
import matplotlib.pyplot as plt

sns.set_theme(palette = "colorblind", font_scale = 1, style = "whitegrid", font = "Verdana")

#Plot measurement_1 all curves on one plot

tdplot.combined_lineplot_w_stdev_as_shadows(replicates, m1_tidy_df, xlabel = 'Time [h]'
                                     , ylabel = keyword1)
plt.savefig(outputname + '_' + keyword1 + "_combined." + format, 
            format = format, dpi = 300)
plt.show()


#Set the size of the plots and margin sizes
plot_width = 6  # width of each subplot in inches
plot_height = 4  # height of each subplot in inches
space = 0.4  # desired spacing between subplots in inches
left = 0.1  # left margin in inches
right = 0.9  # right margin in inches
bottom = 0.1  # bottom margin in inches
top = 0.9  # top margin in inches
ncols, nrows, fig_size = tdplot.optimum_grid(replicates, plot_width, 
                                             plot_height, space, left, right, 
                                             bottom, top)

#Plot measurement_1 as separate subplot for each sample 

tdplot.separate_lineplots_w_stdev_as_shadows(replicates, ncols, nrows, fig_size, 
                                      m1_tidy_df, xlabel = 'Time [h]', 
                                      ylabel = keyword1, same_yscale=True)

plt.savefig(outputname + '_' + keyword1 + "_separate." + format, format = format, dpi = 300)
plt.show()

#Plot measurement_2 as separate subplot for each sample

if args.measurement2:
    
    tdplot.combined_lineplot_w_stdev_as_shadows(replicates, m2_tidy_df, xlabel = 'Time [h]',
                                                ylabel = keyword2)
    plt.savefig(outputname + '_' + keyword2 + "_combined." + format, format = format, dpi = 300)
    plt.show()
    
    tdplot.combined_lineplot_w_stdev_as_shadows(replicates, norm_df, xlabel = 'Time [h]',
                                                ylabel = 'relative_' + keyword2)
    plt.savefig(outputname + '_' + 'relative_' + keyword2 + "_combined." + format, 
                format = format, dpi = 300)
    plt.show()
    
    tdplot.separate_lineplots_w_stdev_as_shadows(replicates, ncols, nrows, fig_size, 
                                          m2_tidy_df, xlabel = 'Time [h]', 
                                          ylabel = keyword2, same_yscale=True)
    
    plt.savefig(outputname + '_' + keyword2 + "_separate." + format, 
                format = format, dpi = 300)
    plt.show()

    #Plot normalized measurements 

    tdplot.separate_lineplots_w_stdev_as_shadows(replicates, ncols, nrows, fig_size, 
                                          norm_df, xlabel = 'Time [h]', 
                                          ylabel = 'relative_' + keyword2, same_yscale=True)
    
    plt.savefig(outputname + '_' + 'relative_' + keyword2 + "_separate." + format, 
                format = format, dpi = 300)
    plt.show()
    
    # Plot paired measurements (with normalized measurements)
    tdplot.paired_plots(replicates, ncols, nrows, fig_size, m1_tidy_df, norm_df, xlabel = 'Time [h]', ylabel1 = keyword1, 
                     ylabel2 = 'relative_' + keyword2, same_yscales = True, 
                     color1 = 'blue', color2 = 'orange')    
    plt.savefig(outputname + "_paired." + format, format = format, dpi = 300)
    plt.show()
print('\n Plots complete.')