# -*- coding: utf-8 -*-
"""
Created on Thu Jun  8 14:08:32 2023

@author: Marina Dziuba
"""
"""
Collection of functions used by Tecan data parser
"""
import sys
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns


##Data processing functions

def test_table_orientation(tecan_tbl, measurements_location):
    '''Check if data in the exel table are in the horizontal orientation. 
    Otherwise the data extraction will not work. Accepts the table generated by 
    Tecan read with pandas and the tuple with row numbers indicating the start and the end of the
    measurements in this table'''
    try:
        test_horizontal = list(tecan_tbl.iloc[measurements_location[0]-1, 1:11])
        test_horizontal = [int(i) for i in test_horizontal]
        test_horizontal == [1,2,3,4,5,6,7,8,9,10] 
    except:
        print("Error: the data in your Excel sheet is not arranged horizontally")
        sys.exit()
        

def select_data(tecan_tbl, measurements_location):
    '''Extract the rows containing data according to the user specified location
    of measurements. Accepts the table generated by Tecan read with pandas and a 
    tuple with row numbers indicating the start and the end of the measurements 
    in this table'''
    
    data = tecan_tbl.iloc[(measurements_location[0]-2):(measurements_location[1]-1), :].reset_index(drop = True)

    return data


def process_time(data):
    '''Extract time (s) from the data, calculate time in hours, and add both to a new dataframe 
    as transformed columns'''
    #create a new dataframe
    time_df = pd.DataFrame(dtype="object")
    for i, r in data.iterrows():
        if r[0] == "Zeit [s]" or r[0] == "Time [s]":
            time_df[0] = r.T
            break
    time_df.reset_index(drop = True, inplace = True)
    
    #Transform time to hours and write the result to a new column
    time_hr = time_df.iloc[1:,0].divide(3600)
    time_hr.loc[-1] = "Time [h]"
    time_hr = time_hr.sort_index()
    time_hr.reset_index(drop = True, inplace = True)
    time_df = pd.concat([time_df, time_hr], axis=1, ignore_index=True)
    
    return time_df


def extract_values_with_multimeasurements(well, data):
    '''Extract the mean value of multiple measurements in a specified well. 
    Suitable if measurements were conducted in several points (a setting 
    available in Tecan i-control software). Well should be passed as a string 
    (e.g., 'A1', 'A2', etc.)'''

    #In our lab, the data could be written in English or in German. 
    #So, it should be tested for correct data extraction
    try:
        well_index = data[data["Application: Tecan i-control"] == well].index
    except:
        well_index = data[data["Programm: Tecan i-control"] == well].index
    
    well_values = data.iloc[well_index + 3, :] #Find the correct row
    well_values_T = well_values.T #Transpose the data from the selected row
    well_values_T.reset_index(drop = True, inplace = True) #Reset the index
    return  well_values_T


def extract_values_with_monomeasurements(well, data):
    '''Extract the values measured in a well if a single measurement was conducted. 
    Well should be passed as a string (e.g., 'A1', 'A2', etc.)'''
    try:
        well_index = data[data["Application: Tecan i-control"] == well].index
    except:
        well_index = data[data["Programm: Tecan i-control"] == well].index
    
    well_values = data.iloc[well_index, :]
    well_values_T = well_values.T #transposes the data from the selected row
    well_values_T.reset_index(drop = True, inplace = True)
    return  well_values_T


def process_extracted_measurements(data, time_df, replicates, blank_values):
    '''Collect measurements for all replicates specified by user, subtract 
    the blank values, calculate mean value and standard deviation for each 
    time point, and add the results to the previously generated dataframe 
    containing time measurements. Return a tidy dataframe with all the 
    extracted data, calculated means and standard deviations.'''

    for k, v in replicates.items():
       for i in v:
           values = extract_values_with_multimeasurements(i, data)
           #subtract blank values from measurements
           values.iloc[1:,0] = values.iloc[1:,0].subtract(blank_values.iloc[1:, 0]) 
           values.iloc[0,0] =str(k + " : " + i)
           tidy_df = pd.concat([time_df, values], axis=1, ignore_index=True)        
       #Calculate mean value for the replicates 
       row_means = data.iloc[1:, -len(v):].mean(axis = 1)
       #Calculate standard deviation for the replicates
       row_std = data.iloc[1:, -len(v):].std(axis = 1)
       #Add mean value the df and assign a name to the column
       tidy_df = pd.concat([tidy_df, row_means], axis=1, ignore_index=True)
       tidy_df.iloc[0,-1] = str(k + " : " + "Mean value")
       #Add st. dev. to the df and assign a name to the column
       tidy_df = pd.concat([tidy_df, row_std], axis = 1, ignore_index=True)
       tidy_df.iloc[0,-1] = str(k + " : " + "St. dev")
      
    #Pass the first row as colum names
    tidy_df.columns = tidy_df.iloc[0]
    tidy_df = tidy_df.drop(0)
    tidy_df.reset_index(drop = True, inplace = True)

    #Correct any values lower than 0 to 0.01. This is needed to avoid negative 
    #values and division by 0. Negative values originate from low sensitivity 
    #of the spectrophotometric measurements in diluted samples.  
    tidy_df[tidy_df < 0] = 0.01
    
    return tidy_df


def write_to_excel(output_name):
    '''Initiate an excel file for writing processed data'''
    excel = pd.ExcelWriter(output_name +".xlsx", engine = "xlsxwriter")
    return excel

## Data plotting functions

def combined_lineplot_w_stdev_as_shadows(replicates, tidy_df, xlabel, ylabel):
    '''Plot mean values of the measuremens as line plots with standard deviations
    as shaded regions on a 
    single plot by looping through columns of the tidy data frame (tidy_df).
    Accepts a dictionary with replicate wells and a tidy pandas df with 
    pre-calculated mean value and st.dev. '''
    fig, ax = plt.subplots(figsize = (10, 8))
    plotted_means = []
    plotted_stds = []
    x = tidy_df['Time [h]'].astype(float)

    for k, v in replicates.items():
        for column in tidy_df.columns:
            if k + " : " + "Mean value" in column:
                y_mean = tidy_df[column].astype(float)
                plotted_means.append(y_mean)
                
                for std_column in tidy_df.columns:
                    if k in std_column and "St. dev" in std_column:
                        y_std = tidy_df[std_column].astype(float)
                        plotted_stds.append(y_std)
                        break
                    
        if len(plotted_means) == len(plotted_stds):
            for mean, std in zip(plotted_means, plotted_stds):
                error = 0.5 * std
                lower = mean - error
                upper = mean + error
                sns.lineplot(x=x, y=mean, ax=ax, label=mean.name.split(":")[0])
                ax.fill_between(x, lower, upper, alpha=0.2)
                
            plotted_means.clear()
            plotted_stds.clear()
    ax.set_xlabel(xlabel)
    ax.set_ylabel(ylabel)


def optimum_grid(replicates, plot_width, plot_height, space, left, right, bottom, top):
    '''Calculates optimum number of rows and columns depending on the number of 
    replicates and pre-set margin sizes. '''
    
    # calculate the optimum number of rows and columns so that no more than 3 plots in one row are plotted
    nrows = int(len(replicates.items()) / 3) + int(len(replicates.items()) % 3 > 0)
    ncols = 3 if len(replicates.items()) >= 3 else len(replicates.items())    
    # Calculation of optimum figure size
    fig_width = ncols * plot_width + (ncols - 1) * space + left + right
    fig_height = nrows * plot_height + (nrows - 1) * space + bottom + top
    fig_size = (fig_width, fig_height)    
    return ncols, nrows, fig_size 


def separate_lineplots_w_stdev_as_shadows(replicates, ncols, nrows, fig_size, df, xlabel, ylabel, same_yscale=True):
    '''Plot values in separate line plots with errors shown as shaded regions 
    by looping through columns and replicates passed by the user.
    Accepts a dictionary with replicate wells and a tidy pandas df with pre-calculated 
    meanvalue and st.dev. '''
    
    fig, axes = plt.subplots(nrows=nrows, ncols=ncols, figsize=fig_size, sharey = False)
    fig.subplots_adjust(hspace=0.5, wspace=0.5) # adjust the spacing between the subplots
    
    x = df['Time [h]'].astype(float)
    plotted_means = []
    plotted_stds = []

    for k, v in replicates.items():
        for column in df.columns:
            if k + " : " + "Mean value" in column:
                y_mean = df[column].astype(float)         
                plotted_means.append(y_mean)                
                for std_column in df.columns:
                    if k in std_column and "St. dev" in std_column:
                        y_std = df[std_column].astype(float)
                        plotted_stds.append(y_std)
                        break
    #Finding min and max of all data to set y axis to the same scale
    if same_yscale is True:
        concat_means = pd.concat(plotted_means, axis = 0)
        concat_std = pd.concat(plotted_stds, axis = 0)
        y_mean_min = concat_means.min()
        y_mean_max = concat_means.max()
        y_std_min = concat_std.min()
        y_std_max = concat_std.max()
        y_min = y_mean_min-0.5*y_std_min
        y_max = y_mean_max + 0.5*y_std_max
    else: 
        pass

    for i, (mean, std) in enumerate(zip(plotted_means, plotted_stds)):
        c = i % ncols
        r = i // ncols
        error = 0.5 * std
        lower = mean - error
        upper = mean + error
        ax = axes[r, c]
        sns.lineplot(x=x, y=mean, ax=ax, label=mean.name.split(":")[0])
        ax.fill_between(x, lower, upper, alpha=0.2)
        if same_yscale is True:
            ax.set_ylim(y_min, y_max)
        ax.set_xlabel(xlabel)
        ax.set_ylabel(ylabel)
    plotted_means.clear()
    plotted_stds.clear()
    
    if ncols * nrows > len(replicates.items()):
        n_to_hide = ncols * nrows - len(replicates.items())
        while n_to_hide > 0:    
            axes[nrows - 1, n_to_hide].set_visible(False)
            n_to_hide = n_to_hide - 1
            
